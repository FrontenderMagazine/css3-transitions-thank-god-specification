# Слава богу, у нас есть спецификация!

В этой статье собраны описания странностей и проблемных моментов, о которых вам 
нужно знать при работе с CSS3-переходами (transitions). 
Обратите внимание, что я не предлагаю обходные приёмы и не даю советы 
по решению описанных проблем. Алекс МакКоу (Alex MacCaw) уже написал 
очень глубокую и основательную статью «[Всё что вам нужно 
знать о CSS-переходах][1]». 

Алекс написал как добиться конкретных эффектов, я же собираюсь 
описать техническую подноготную, особенно всё, что связано с JavaScript. 
**Подводные камни - эта статья именно про них**. Вот 
содержание, если вы хотите сразу перейти к конкретному разделу: 

01. [Описание перехода](#1-specifying-a-transition)
02. [Когда переход завершен](#2-when-a-transition-is-complete)
03. [Свойства, для которых могут быть применены переходы](#3-transitionable-properties)
04. [Приоритет свойств переходов](#4-priority-of-transition-properties)
05. [Переход от/к значению `auto`](#5-transitioning-from-and-to-auto)
06. [Неявные переходы](#6-implicit-transitions)
07. [Переходы и псевдоэлементы](#7-transitions-and-pseudo-elements)
08. [Фоновые вкладки](#8-background-tabs)
09. [«Невидимые» элементы](#9-invisible-elements)
10. [Осуществление перехода до полной загрузки DOM](#10-transitioning-before-the-dom-is-ready)
11. [Особенности отрисовки](#11-rendering-quirks)
12. [Рекомендации относительно спецификации](#12-recommendations-for-the-specification)
13. [Используй `delay`, Люк!](#13-use-the-delay-luke)
14. [Заключение](#14-conclusion)

Разделение на составляющие не является чем-то новым, именно этим 
подходом мы руководствуемся уже не первый год используя 
шаблонизаторы, чтобы отделить HTML от используемого 
скриптового языка. **У вебсайта есть три основных составляющие:** 
структура (HTML), макет и стиль (CSS) и поведение (JavaScript). 
В случае с CSS грань уже давно стерта, и его используют 
для описания поведения элементов, однако это тема для 
отдельного обсуждения. 

Несколько недель назад передо мной была поставлена задача: разработать 
JavaScript-модуль, который бы позволил использовать CSS-переходы таким образом, 
чтобы JavaScript ничего не знал о происходящих переходах. 
**Настоящей проблемой стала асинхронность переходов**. 
После написания некоторого количества тестов я сдался: задача не может 
быть выполнена разумным количеством кода и с приемлемым временем
инициализации. В этой статье представлены результаты моих тестов.

Перед тем как приступить к теме переходов, нам нужно рассмотреть небольшую часто 
используемую вспомогательную функцию. `getComputedStyle()` — это метод 
JavaScript, который возвращает значение CSS-свойства в том виде, в каком его 
отдаёт браузер. Этот API берет начало в «[DOM Level 2: getComputedStyle()][2]» 
и «[CSS Level 2: Computed Values][3]», в которых вычисленный стиль 
определён как абсолютное значение. 

Её можно отлично использовать для свойств вроде `font-size`, 
которые принимают только один параметр и безопасно конвертируются 
в пиксельные значения. Однако не описано как браузеры должны обрабатывать 
сокращенные записи свойств вроде `margin` — некоторые браузеры 
не возвращают никакие значения, другие возвращают что-то относительно
полезное. Кроме того, существуют свойства, которые могут принимать разные, но 
эквивалентные значения, например, `bold` и `700` для `font-weight`. Также в WebKit 
есть [глюк][4], который извлекает вычисленное значение свойств из 
псевдо-элементов. 

*Странности, описанные в этой статье, были обнаружены в январе 2013 года 
в браузерах Firefox 18 (Gecko), Opera 12.12 (Presto), 
Internet Explorer 10 (Trident), Safari 6.0.2 (WebKit), Chrome 23 (WebKit), 
а также ночных сборках Gecko и WebKit.*

Без дальнейших проволочек **давайте погрузимся в спецификации и их реализации** — 
в мир, полный недоразумений. Обратите внимание, что для краткости 
я опустил вендорные префиксы.

> «Трудно иметь дело с тем, чего не знаешь. Гораздо легче предполагать.» — Д-р Аксель Раушмайер (Dr. Axel Rauschmayer)

… Однако предположения часто оказываются ошибочными. Информация в этой статье 
была получена в результате работы над [набором тестов для CSS3-переходов][5].

<a id="1-specifying-a-transition"></a>
## 1. Описание перехода

Помимо сокращенной записи [свойства][6] `transition`, в спецификации 
по CSS3-переходам указаны ещё четыре свойства для 
управления анимированным изменением состояния:

* `transition-property`,

* `transition-duration`,

* `transition-delay`,

* `transition-timing-function`.

### Свойства CSS, для которых выполняется переход

[Свойство][7] `transition-property` определяет **свойство (или свойства), для 
которых будет осуществляться анимация**. Значением по умолчанию является `all`, 
которое означает, что будут анимированы все свойства, для которых может быть 
применён переход (если для `transition-duration` задано значение больше `0s`). Это 
свойство принимает одно значение или список значений, разделенных запятыми (как и 
все свойства типа `transition-*`).

В спецификации говорится, что браузер должен принять и сохранить любое свойство, 
которое он не смог распознать. Следовательно, в примере ниже должен 
происходить переход для свойства `padding` длительностью в 2 секунды. 

    transition-property: foobar, padding; 
    transition-duration: 1s, 2s;

Вопреки спецификации, WebKit интерпретирует этот код как 
`transition-property: all`. Firefox и Opera — как `transition-property: all, padding`.

### Длительность перехода

Свойство `transition-duration` определяет **количество времени**, которое должен
занимать переход от начала изменения состояния до его конца. Оно 
принимает значение времени в секундах или миллисекундах (например, и `2.3s`, и 
`2300ms` обозначают 2.3 секунды).

Хотя в спецификации чётко указано, что значения должны быть положительными 
числами, Opera также поддерживает `-5s`, по крайней мере, для `getComputedStyle()`. 
Opera и Internet Explorer (IE) не поддерживают значения меньше `10ms`, хотя в 
спецификации нет ни слова о таком ограничении. Справедливости ради, вы бы в 
любом случае не заметили переход длящийся 9 миллисекунд. WebKit (за исключением 
текущей ночной сборки) содержит ошибку в реализации `getComputedStyle()`, 
поэтому возвращает значения вроде `0.009999999776482582s` вместо `0.01s`. По 
крайней мере, все браузеры возвращают значения в секундах. 

### Задержка перехода

Свойство `transition-delay` определяет время ожидания, которое должно 
пройти до начала** перехода; оно также принимает временные значения. Свойство 
может принимать отрицательные значения, при которых переход будет 
начинаться немедленно и выглядеть так, будто начался на заданное количество 
времени раньше — как будто с прыжка. 

Так же как и для `transition-duration`, IE и Opera не поддерживают значения 
между `-10ms` и `10ms`. У WebKit и в этом случае проблемы с плавающей 
точкой. 

### Временная функция

[Свойство][10] `transition-timing-function` определяет **математическую функцию, 
которая используется для рассчёта значения свойства** во время `t`. Есть 
три основных функции: `cubic-bezier(x1, y1, x2, y2)`, `step(<number>`, 
`start|end)` и ключевые слова, которые обозначают предопределённые кривые Безье. 
Скорее всего, вы уже знаете ключевые слова `linear`, `ease`, `ease-in`, 
`ease-out` и `ease-in-out`. Понимать математические вычисления кривых Безье не 
обязательно, потому что можно использовать чудесный 
[редактор кривых Безье][12], созданный [Леа Веру (Lea Verou)][11]. 
В то время как кривые Безье делают переходы плавными, функция `step()` 
действует наоборот: она задаёт скачкообразный переход к следующему значению 
(т.е. следующему шагу) через одинаковые промежутки времени. 
Это позволяет создавать покадровую анимацию, примеры 
такой анимации можно посмотреть в статье «[Анимация набора текста на чистом CSS3 с помощью функции steps()][13]».

Вычисленное значение `linear` обычно представлено в виде
`cubic-bezier(0, 0, 1, 1)`, кроме WebKit, который возвращает `linear`. Но 
волноваться не стоит: WebKit всё ещё возвращает `cubic-bezier(0.25, 0.1, 0.25, 1)` 
вместо `ease`. Хотя текущая ночная сборка WebKit возвращает ключевое слово 
для всех стандартных ключевых слов. Впрочем, если смотреть на вещи позитивно, 
WebKit стремится к тому, чтобы перестать противоречить хотя бы самому себе, 
так что через несколько месяцев он будет противоречить только другим браузерам. 

Спецификация гласит, что значение `x` должно быть между `0` и `1`, в то 
время как значение `y` может выходить за пределы этого диапазона. Вопреки 
спецификации, WebKit допускает значения `x` выходящие за пределы диапазона, по 
крайней мере в вычислениях. На момент написания этой статьи браузер Android 
(версия 4.0) смешивал диапазоны для `x` и `y`, по сути делая невозможным эффект 
"подпрыгивания" (bounce). 

<a id="2-when-a-transition-is-complete"></a>
## 2. Когда переход завершен

Я уже упоминал, что CSS-переходы выполняются асинхронно. В спецификации предложено 
событие `TransitionEnd` для возможности синхронизировать JavaScript с окончанием 
перехода. К сожалению, это событие недостаточно подробно описано в спецификации. 
По сути, в ней всего лишь сказано, что событие должно быть вызвано для каждого 
свойства, для которого был осуществлен переход. Если описывать ситуацию одним 
словом, «кошмар» вполне подходит. 

В спецификации указано, что когда переход задан для сокращенной записи свойств 
(таких как `padding`), он должен осуществляться для всех свойств, которые эта 
запись в себя включает (`padding-top`, `padding-right`, и т.д.), однако не 
уточняется какое свойство должно быть указано в событии `TransitionEnd`. В то 
время как Gecko, Trident и Presto придерживаются тактики запуска событий 
для всех компонентов из полной записи свойства (например, `padding-top`), даже если 
переход был задан для сокращенной записи свойства (например `padding`), 
**WebKit воспользовался возможностью сделать всё наперекосяк**. WebKit вызывает 
событие для `padding` если (и это обязательное условие) вы указали 
`transition-property: padding`, однако `transition-property: all` запускает 
событие для `padding-left` и других. По непонятной причине браузер Safari 6.0.1 
на iPhone вызывает события для `font-size` и `line-height` когда осуществляется 
переход для `padding`. Вы еще не запутались?

    .example {
      padding: 1px;
      transition-property: padding;
      transition-duration: 1s;
    }

    .example:hover {
      padding: 10px;
    }

CSS-код, приведённый выше, вызовет разные события `TransitionEnd` в разных 
браузерах:

Gecko, Trident, Presto:

`padding-top`, `padding-right`, `padding-bottom`, `padding-left`

WebKit:

`padding`

    .example {
      padding: 1px;
      transition-property: all, padding;
      transition-duration: 1s;
    }

    .example:hover {
      padding: 10px;
    }

CSS-код, приведённый выше, также вызовет разные события `TransitionEnd` в разных 
браузерах:

Gecko, Trident, Presto, WebKit:

`padding-top`, `padding-right`, `padding-bottom`, `padding-left`

Safari 6.0.1 на iPhone (не iPad, учтите!):

`padding-top`, `padding-right`, `padding-bottom`, `padding-left`, `font-size`, 
`line-height`

Я уже говорил, что можно задать отрицательное значение `transition-delay`, чтобы 
переход начинался как бы заранее. Но что же происходит при 
`transition-duration: 1s; transition-delay: -1s;`? Gecko и WebKit сразу 
отображают конечное значение и вызывают событие. Trident и Presto не вызывают 
никаких событий. 

**Проблема с плавающей запятой, характерная для WebKit** при 
`getComputedStyle()`, также встречается во всех браузерах при 
`TransitionEnd.elapsedTime`. `Math.round(event.elapsedTime * 1000) / 1000` может 
это «исправить».

WebKit и IE ввели [нестандартное дополнение][14] для `background-position`, не 
указанное в спецификации, которое приводит к вызову событий `TransitionEnd` для 
`background-position-x` и `background-position-y`, вместо `background-position`.

Таким образом, даже зная что переход произошёл, вы не можете рассчитывать на 
`TransitionEnd.propertyName`. Вы можете написать тонны кода JavaScript чтобы 
управлять поведением, но вы не можете гарантировать его стабильную работу в 
будущем без проведения соответствующего определения признаков для каждого 
свойства. В том числе для свойств, к которым, на ваш взгляд, не может быть 
применена анимация. 

<a id="3-transitionable-properties"></a>
## 3. Свойства, для которых могут быть применены переходы

В спецификации [приведен список свойств CSS][15], для которых браузеры должны 
поддерживать анимированые переходы. Этот список содержит свойства из CSS2.1. Для 
всех более новых свойств в их спецификации добавляется 
пометка о возможности применения анимации, как, например, для свойства 
`order` [в спецификации Flexible Box Layout][16]. 

Важным фактором является тип значения, которое принимает свойство. Свойство 
`margin-top` принимает значения в единицах длины и процентах, но согласно списку 
свойств CSS, для которых могут быть применены переходы, анимация может быть 
задана только для значений длины. Однако это не помешало разработчикам браузеров 
ввести поддержку переходов для значений в процентах. Со свойством `word-spacing` 
совсем другая история. Согласно спецификации, его значение в процентах может 
быть анимировано, но ни один браузер такую анимацию не поддерживает. 

Для свойства осуществляется переход от значения A до значения B без учёта событий 
`TransitionEnd` если его значение `getComputedStyle()` отличается от A и B в 
соответствующее время перехода. Поскольку нет такого события как «изменение 
значения свойства CSS», вам остается **только вести наблюдение за DOM**. Решение 
`setTimeout()` не подходит для быстрых переходов (длительностью менее  
нескольких сот миллисекунд). Здесь вам поможет `requestAnimationFrame()`. Браузер 
выведет предупреждение перед началом перерисовки изображения на экране, что 
позволяет захватить пару промежуточных значений во время переходов. У всех 
браузеров кроме Opera уже есть эта функция. 

Чтобы не раздувать эту статью размещением полной таблицы совместимости, 
я отправил полученные результаты Оли Стадхолму (Oli Studholme, [@boblet][17]) и 
он обновил свой список «[Свойства CSS, к которым может быть применена анимация][18]». 

<a id="4-priority-of-transition-properties"></a>
## 4. Приоритет свойств переходов

Спецификация для [свойства][19] `transition-property` говорит, что мы можем 
указывать в нём несколько свойств:

> « Если в качестве значения `transition-property` указано несколько свойств (в 
полном виде, в сокращенной записи или через значение `all`), то начавшийся 
переход будет иметь значение продолжительности, задержки и синхронизации, 
соответствующее последнему пункту в значении `transition-property`, которое 
определяет возможности анимации»

Таким образом, мы можем сделать переход для `padding` длительностью в 1 секунду 
и одновременно переход для `padding-left` длительностью в 2 секунды; или указать 
стиль перехода по умолчанию используя `transition-property: all` и переписать 
его для некоторых свойств.

В Firefox и IE всё это отлично работает. В Opera же порядок приоритетов 
перемешан. Вместо осуществления перехода для свойств из списка *по очереди*, 
`padding-left` получает больший приоритет, чем `padding` и `all`.

Настоящую проблему представляет WebKit. В нём, если задано несколько свойств, 
переход почему-то осуществляется несколько раз. Чтобы окончательно вывести 
WebKit из себя, попробуйте запустить переход для `transition-property: padding, 
padding-left` с очень малым `transition-duration: 0.1s` (предупреждение: 
эпилептикам этого делать не стоит). WebKit отображает переход по меньшей мере 
дважды. Но настоящая прелесть – это события `TransitionEnd`, 
которых вы можете получить *сотни* для одного перехода.

<a id="5-transitioning-from-and-to-auto"></a>
## 5. Переход от и к `auto`

Значение свойства CSS `auto` можно интерпретировать как «Уважаемые браузеры, 
пожалуйста, вычислите приемлемое значение для вот этого». Абзацы (`<p>`) и любые 
блочные элементы будут иметь ту же ширину, что и их родительские элементы, если 
для них установлено `width: auto`. В определенных ситуациях, когда вам нужно
изменить ширину от `auto` до конкретного значения, возникает необходимость 
использования CSS-перехода. Спецификация не высказывается ни за ни против 
значений `auto` для свойств с переходами. 

В Firefox, IE и Opera невозможен переход от или к значениям `auto`. У IE 
существует небольшое исключение только для `z-index`. WebKit, однако же, 
поддерживает переход от и к значению `auto` практически для любого CSS-свойства, 
которое его принимает. WebKit не очень хорошо воспринимает `clip`: для 
этого свойства будет вызываться только событие `TransitionEnd` без генерации или 
показа любого промежуточного значения или состояния во время перехода.

Другие свойства, например, такие как `width` и `height`, в WebKit ведут себя 
совсем не так, как вы ожидаете. Если установлено значение `width: auto` с 
рассчитанной шириной 300px, а вы задали переход 
от него до 100px, то, на самом деле, это не значит, что ширина уменьшится 
от 300 до 100 пикселей — вместо этого, она будет увеличиваться от 0 до 100 пикселей.

Полную таблицу совместимости можно просмотреть в публикации «[Свойства CSS, к 
которым может быть применена анимация][20]»

<a id="6-implicit-transitions"></a>
## 6. Неявные переходы

«Неявные переходы» происходят, когда изменение одного свойства вызывает 
переход для другого свойства. То же явление наблюдается, если вы изменяете 
свойства родительского элемента и это вызывает переход зависимого или 
унаследованного свойства у дочерних элементов. Немного запутано, не правда ли? 
В качестве примера рассмотрим 
`font-size: 18px; padding: 2em;` — отступы рассчитываются как 
`2 × font-size`, ведь именно так работают em, что даёт нам 36 пикселей.

Существуют различные *относительные типы величин*: `<percentage>`, `<length>`, 
`em`, `rem`, `vh`, `vw` и т.д. Использование относительных величин, например, 
`padding: 2em`, заставляет браузер выполнять перерасчёт значения функции 
`getComputedValue()` каждый раз, когда происходит изменение зависимого от него 
значения (например, `font-size`). В свою очередь это вызывает переход для 
`padding`, поскольку изменился вычисленный стиль. Этот переход считается 
«неявным», потому что свойство `padding` не было изменено явным образом.

Большинство браузеров поддерживает возможность неявных переходов. Исключением 
является IE 10, который поддерживает их только для свойства `line-height`. В 
WebKit неявные переходы работают для всех свойств, которым можно задать переход, 
за исключением `vertical-align`. Кроме значений, привязанных к шрифтам, есть 
также значения относящиеся к ширине (обычно в `<percentage>`), 
значения, привязанные к области просмотра (например, `vh` и `vw`), 
исходные значения по умолчанию (например, `column-gap: 1em` в Opera) 
и наконец, `currentColor`. Все эти значения могут инициировать неявные переходы.

В браузере Firefox неявные переходы работают особенно интересно когда и 
зависимые, и зависящие элементы совершили переход, но их свойства 
`transition-duration` или `transition-delay` не совпадают. В то время как в 
WebKit и Opera переходы выглядят логично, Firefox несколько искажает результат. 
Браузера IE эта проблема не касается, потому что он не поддерживает неявные 
переходы.

Не забывайте о каскадном наследовании. Значение свойства `font-size` 
элемента DOM будет унаследовано его дочерними элементами, если оно не 
переопределено, что может привести к неявным переходам.

<a id="7-transitions-and-pseudo-elements"></a>
## 7. Переходы и псевдо-элементы

Псевдо-элементы (`:before` и `:after`) были представлены в спецификации 
[CSS2 generated content][21]. Если вы не знакомы с генерируемым содержимим, 
рекомендую  прочитать статью 
«[Учимся ипользовать псевдо-элементы :before и :after][22]». Хотя в 
спецификации [CSS3 content][23] описаны дополнительные 
псевдо-элементы (`::alternate`, `::outside`), они (пока) 
не поддерживаются браузерами. Все анимируемые CSS-свойства также 
должны анимироваться и для псевдо-элементов.

Браузеры Firefox и IE 10 поддерживают переходы для свойств, 
заданных псевдо-элементам, в отличии от Opera, Chrome и Safari. 
WebKit добавил поддержку таких переходов в январе 2013 года, 
что из этого вышло можно посмотреть в [ночной сборке WebKit][24] 
и [сборке Chrome Canary][25].

Переходы генерируемого содержимого привнесли новые странности. 
События `TransitionEnd` не работают вообще. Когда-то в будущем они должны будут 
вызываться для главного элемента и добавлять псевдо-элемент через 
`TransitionEnd.pseudoElement`. Но даже в разделе «[Transition Events][26]» в 
редакторском черновике «CSS Transitions» это еще толком не описано.

Когда-то давно иногда возникала необходимость изменять значение свойства 
`content`, чтобы IE 8 перерисовывал элемент (например, при `:hover`). 
Оказывается, такое использование свойства для старых IE 
мешает реализации этой возможности для всех остальных браузеров. 
Так что при попытке реализации перехода для свойства псевдо-элемента
убедитесь, что `content` не был изменён.

IE 10 не будет осуществлять переход для состояния `:hover` псевдо-элемента, если 
его родительский элемент не имеет такое же состояние `:hover`:

    .some-selector:before {
      content: "hello";
      color: red;
      transition: all 1s linear 0s;
    }
    
    .some-selector:hover:before {
      color: green;
    }
    /* Следующее правило нужно для запуска перехода в :before при наведении курсора в IE 10 */
    .some-selector:hover {}

Странность здесь не в том, что вам потребуется наличие (возможно, пустого) 
состояния `:hover` у родительского элемента, а в том, что если его у вас нет, IE 
10 будет интерпретировать `:hover` как `:active` (т.е. как активный элемент, по 
которому кликнули). Самое странное в этом то, что состояние `:active` сохраняется 
даже после клика и удаляется только при повторном клике по документу.

<a id="8-background-tabs"></a>
## 8. Фоновые вкладки

На момент написания статьи IE 10 является единственным браузером, который 
принимает во внимание расположение вкладок в фоне 
или на переднем плане. Хотя текущий 
переход и будет завершен если вкладка перешла фоновый режим, новые переходы 
выполняться не будут. IE 10 перед началом любых новых переходов подождёт пока вкладка не станет активной. К счастью, IE 10 уже поддерживает [API 
видимости страницы][27], который позволяет разработчикам контролировать такое 
поведение.

Можно ожидать, что подобное будет реализовано и в других браузерах, 
поскольку в данный момент они продолжают переводить фоновые вкладки в режим сна.

<a id="9-invisible-elements"></a>
## 9. «Невидимые» элементы

Выполняются ли переходы для элементов DOM, которые не привязаны к DOM? Нет, ни в 
одном браузере они не выполняются, потому что зачем? А как насчёт скрытых элементов? 
Разработчики большинства браузеров пришли к выводу, что нет 
необходимости запускать переходы для невидимых (т.е. неотрисованных) элементов. 
У браузера Opera другое мнение по этому вопросу: в нём переходы 
работают независимо от того, отрисован элемент или нет.

<a id="10-transitioning-before-the-dom-is-ready"></a>
## 10. Осуществление перехода до полной загрузки DOM

Событие `DOMContentLoaded` срабатывает, когда документ выходит из режима парсинга. 
Если вы работаете с JQuery, сейчас мы говорим о `jQuery.ready()`. 
Переходы могут быть произведены *до того*, как это событие произойдёт.

<a id="11-rendering-quirks"></a>
## 11. Особенности отрисовки

До сих пор я описывал странности, обнаруженные при тестировании информации 
изложенной в спецификации. Тесты проводились в автоматическом режиме. Однако, как 
оказалось, есть ещё несколько проблем, которые можно увидеть только глазами.
Следующие неточности были обнаружены другими разработчиками 
и вполне могут повлиять на вашу работу с переходами.

В данное время переход фона от одного градиента к другому градиенту 
невозможен. Переход от градиента к одному цвету 
возможен — но с важной оговоркой. Если переход 
начинается с градиента, переход будет происходить от белого цвета до 
конечного. При этом будет наблюдаться секундный проблеск белого цвета в начале 
перехода. Данный эффект можно [наблюдать][28] во всех существующих браузерах.

Firefox использует другой алгоритм для отрисовки (и сглаживания) изображений в 
процессе анимации ([посмотреть пример][29]). Судя по всему, при 
выполнении переходов Gecko жертвует качеством в пользу производительности. 
Обратите внимание, что это происходит [при достаточно низком значении `transform: scale()`][30].

Firefox не хочет корректно анимировать переход от `a:visited` к `a:hover` 
и наоборот. Вместо этого будут происходить прыжки от `a:visited` 
к `a:link`, а затем переход к `a:hover`, как вы можете увидеть [в этом 
примере][31]. Частично об этом говорится в публикации «[Конфиденциальность и 
селектор :visited][32]» от разработчиков Mozilla. IE 10 анимирует такие 
переходы должным образом, так же как Chrome, Safari и Opera, и кроме этого, он 
отображает переход от `a:link` к `a:visited` при загрузке страницы. 

Переходы для нескольких свойств не синхронизированы в Firefox и Webkit. [В этом 
примере][33] вы можете посмотреть как уменьшение значения `border` на ту же 
величину, на которую увеличивается значение `padding` (и наоборот) заставляет 
последующий контент слегка дрожать. IE 10 и Opera всё работает правильно.

[Как вы можете увидеть][34], Firefox не выполняет анимацию свойств элемента, 
если позиционирование одного из родительских свойств было изменено. Webkit, 
Opera и IE 10 всё отображают правильно.

<a id="12-recommendations-for-the-specification"></a>
## 12. Рекомендации относительно спецификации

Проанализировав спецификацию сверху донизу и протестировав все ее описания, я 
могу предложить несколько изменений, которые были бы полезными:

* Добавление события `TransitionsEnd` (обратите внимание на множественное число), 
которое запускалось бы как только *все* переходы для элемента завершены. Это 
позволит получить список свойств, которые были анимированы — но я не могу 
придумать пример когда нужно знать для какого свойства был выполнен переход 
вдобавок к информации когда все анимации завершены.

* Добавление события `TransitionStart`, которое запускалось бы для каждого 
свойства, для которого начинается переход. Поскольку события DOM не дёшевы, а 
цикл событий и поток отрисовки в JavaScript не обязательно блокируют друг друга, 
одно событие TransitionsStart (снова в множественном числе) кажется лучшим 
решением. Я не понимаю, почему у меня должна быть возможность применить 
`cancel`, ведь это будет что-то вроде «выстрелил и забыл».

* Более подробное описание для чего должно быть вызвано событие TransitionEnd. 
Проблема с `padding` и `padding-left` в WebKit немного раздражает.

* Добавление чёткого объяснения того, как должны осуществляться «неявные 
переходы», например, для `line-height: 1em` при `transition-property: font-size`.

* Добавление псевдо-класса `::transitioning`, который позволяет задать 
`pointer-events: none` для предотвращения случайного отображения состояния 
наведения (и прочего). Хитрость тут в том, чтобы предотвратить применение стилей, 
которые будут вызывать новый переход или могут привести к изменению уже 
запущенного перехода.

В дополнение к этим предложениям, мы должны иметь возможность выполнять ряд 
общих (простых) действий без использования объемных кодов JavaScript для решения 
проблемы:

* Иногда может возникнуть необходимость в полном отключении всех переходов. 
Например, такая ситуация может возникнуть при изменении макета, когда нужно 
рассчитать размеры и положение элементов до того, как переходы станут видны 
пользователям.

* Иногда возникает желание удалить объект из DOM, и вы хотите, чтобы этот процесс 
был анимированным. Скорее всего вы добавите класс, подождете завершение события 
`TransitionEnd`, а затем удалите элемент.

* Подобно ситуации с удалением некоторых элементов, может возникнуть 
необходимость в добавлении нового элемента и анимирования его внешнего вида. Вы 
должны вставить элемент, установить «невидимый стиль», запустить перерисовку, а 
затем вернуться к фактическому стилю нового элемента.

* Изменение порядка, скрытие и отображение элементов - это обычные действия 
для любого веб-приложения. В настоящее время для выполнения этих задач требуется 
запуск специальной утилиты, например, [Isotope][35]. Использование 
возможностей CSS может сэкономить несколько байтов.

<a id="13-use-the-delay-luke"></a>
## 13. Используй `delay`, Люк! 

Представьте себе некоторое количество элементов, размещенных близко друг к другу. 
Представьте, что стиль этих элементов при наведении курсора мыши может 
изменяться. Представьте умеренно быстрое перемещение курсора по этим элементам. 
Что происходит? Правильно: вы увидите, что [стили этих элементов мигают][36]. 

Добавив относительно короткую задержку перехода, вы можете [регулировать этот 
эффект][37]; задержка в 20 миллисекунд не воспринимается человеческим глазом, но 
этого достаточно для перемещения курсора мыши по небольшим элементам. Не будет 
ощущения, что переходы отстают, и визуальное раздражение просто исчезает. Простой 
трюк, я знаю.

<a id="14-conclusion"></a>
## 14. Заключение

* Будьте очень осторожны при использовании `transition-property: all`. Вы 
*можете* вызвать события `TransitionEnd` для свойств, которые вы не собирались 
анимировать.

* Будьте осторожны при использовании сокращенных записей, так как количество 
вызванных событий может отличаться от браузера к браузеру.

* Браузеры Opera и IE не инициируют события, если отрицательная задержка равна 
длительности перехода.

* У WebKit серьезные проблемы с приоритетом свойств, таких как 
`transition-property: margin, margin-left`. Постарайтесь пока их не использовать.

* Браузер IE не поддерживает неявные переходы — например, запуск перехода для 
`padding: 2em`, когда изменяется `font-size`.

* Браузеры Firefox и Opera не понимают `transition-property: all, width`.

* В Opera приоритеты свойств перемешаны.

* Переходы для псевдо-элементов не вызывают событие `TransitionEnd`.

* В браузере IE 10 возникают странные ошибки при использовании `:hover` для 
перехода псевдо-элементов.

* Спецификации еще предстоит долгий путь к совершенству.

### Дополнительные ресурсы

Если вы интересуетесь переходами и анимацией и хотите использовать их с умом, 
взгляните на эти замечательные сайты:

* «[Создание динамических визуальных эффектов с помощью переходов CSS3][38]», 
Майк Сьерра (Mike Sierra), Web Platform Docs.

* «[Все, что нужно знать о CSS-переходах][39]», Алекс МакКоу (Alex MacCaw).

* [Эффективные переходы][40].

* «[Переходы в интерфейсах][41]», Паскаль де Сильва (Pasquale 
D’Silva).

* [Анимирование][42] (образцы переходов), Леа Веру (Lea Verou).

* «[CSS-свойства, которые можно анимировать][43]», Оли Стадхольм.

*Хочу сказать спасибо [Оли Стадхольму][44] и [Леа Веру][45] за то, что они нашли 
время просмотреть эту статью до публикации. Также хочу выразить благодарность 
[Петеру Линсу (Peter Linss)][46] за ознакомление со спецификой инфраструктуры 
тестирования рабочей группы по CSS.*

[1]: http://blog.alexmaccaw.com/css-transitions
[2]: http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSview-getComputedStyle
[3]: http://www.w3.org/TR/1998/REC-CSS2-19980512/cascade.html#computed-value
[4]: https://bugs.webkit.org/show_bug.cgi?id=106535
[5]: http://test.csswg.org/shepherd/search/spec/CSS3-TRANSITIONS/
[6]: http://www.w3.org/TR/css3-transitions/#transition-property-property
[7]: http://www.w3.org/TR/css3-transitions/#transition-property-property
[8]: http://www.w3.org/TR/css3-transitions/#transition-duration-property
[9]: http://www.w3.org/TR/css3-transitions/#transition-delay-property
[10]: http://www.w3.org/TR/css3-transitions/#transition-timing-function-property
[11]: https://twitter.com/LeaVerou
[12]: http://cubic-bezier.com/#.17,.67,.83,.67
[13]: http://lea.verou.me/2011/09/pure-css3-typing-animation-with-steps/
[14]: http://snook.ca/archives/html_and_css/background-position-x-y
[15]: http://www.w3.org/TR/css3-transitions/#animatable-css
[16]: http://www.w3.org/TR/css3-flexbox/#order-property
[17]: https://twitter.com/boblet
[18]: http://oli.jp/2010/css-animatable-properties/
[19]: http://www.w3.org/TR/css3-transitions/#transition-property-property
[20]: http://oli.jp/2010/css-animatable-properties/
[21]: http://www.w3.org/TR/CSS2/generate.html
[22]: http://coding.smashingmagazine.com/2011/07/13/learning-to-use-the-before-and-after-pseudo-elements-in-css/
[23]: http://www.w3.org/TR/css3-content/
[24]: http://nightly.webkit.org/
[25]: https://www.google.com/intl/en/chrome/browser/canary.html 
[26]: http://dev.w3.org/csswg/css-transitions/#transition-events
[27]: http://www.w3.org/TR/page-visibility/
[28]: http://jsbin.com/oyuciz/1
[29]: http://jsfiddle.net/fSjUb/3/
[30]: https://bugzilla.mozilla.org/show_bug.cgi?id=860261
[31]: http://jsbin.com/avabaw/1
[32]: https://developer.mozilla.org/en-US/docs/CSS/Privacy_and_the_:visited_selector
[33]: http://jsbin.com/uxenaz/1
[34]: http://jsbin.com/azipul/1
[35]: http://isotope.metafizzy.co/
[36]: http://jsbin.com/irazox/1
[37]: http://jsbin.com/egeniz/1
[38]: http://docs.webplatform.org/wiki/tutorials/css_transitions
[39]: http://blog.alexmaccaw.com/css-transitions
[40]: http://www.ui-transitions.com/#home
[41]: https://medium.com/design-ux/926eb80d64e3
[42]: http://leaverou.github.io/animatable/
[43]: http://oli.jp/2010/css-animatable-properties/
[44]: http://oli.jp/
[45]: http://lea.verou.me/
[46]: https://blog.linss.com/
[47]: https://medium.com/design-ux/926eb80d64e3
