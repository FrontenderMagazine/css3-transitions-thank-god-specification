# Слава богу у нас есть спецификация!

В этой статье собраны описания особенностей и проблемных моментов, о которых вам нужно знать при работе с переходами CSS3. Имейте ввиду что я не предлагаю никакие временные решения и не даю советы по обходу описанных проблем. Алекс МакКоу (Alex MacCaw) уже написал очень подробную статью «[Всё что вам нужно знать о переходах CSS][1]». 

Тогда как Алекс написал о том как добиться того или иного эффекта, я собираюсь описать техническую подноготную, особенно то что связано с JavaScript. **Подводные камни - это то чему полностью посвящена эта статья**. Вот содержание если вы хотите перейти к конкретному разделу: 

01. [Описание перехода](#1-specifying-a-transition)
02. [Когда переход завершен](#2-when-a-transition-is-complete)
03. [Свойства, для которых могут быть применены переходы](#3-transitionable-properties)
04. [Приоритет свойств переходов](#4-priority-of-transition-properties)
05. [Переход от и к `auto`](#5-transitioning-from-and-to-auto)
06. [Неявные переходы](#6-implicit-transitions)
07. [Переходы и псевдо-элементы](#7-transitions-and-pseudo-elements)
08. [Фоновые вкладки](#8-background-tabs)
09. [«Невидимые» элементы](#9-invisible-elements)
10. [Осуществление перехода до полной загрузки DOM](#10-transitioning-before-the-dom-is-ready)
11. [Особенности отрисовки](#11-rendering-quirks)
12. [Рекомендации касательно спецификации](#12-recommendations-for-the-specification)
13. [Используй `delay`, Люк!](#13-use-the-delay-luke)
14. [Заключение](#14-conclusion)

Разделение на составляющие - не новый подход, именно им мы руководствуемся уже не первый год используя шаблонизаторы, чтобы разделить HTML и используемый скриптовый язык. **У вебсайта есть три составляющие:** структура (HTML), макет и стиль (CSS) и поведение (JavaScript). В случае с CSS грань уже давно размыта и его используют чтобы описывать поведение элементов, однако это тема для отдельного обсуждения. 

Несколько недель назад передо мной была поставлена задача разработать модуль JavaScript, который бы позволил использовать переходы таким образом, чтобы JavaScript не получал информацию о происходящих переходах. **Асинхронность переходов стала существенной проблемой**. После написания множества тестов я здался. Эта задача не может быть выполнена при приемлемом количестве кода и времени инициализации. В этой статье представлены результаты моих тестов.

Перед тем как приступить к теме переходов, нам нужно рассмотреть маленькую часто используемую вспомогательную функцию. `getComputedStyle()` — это метод JavaScript, который возвращает значение свойства CSS в том виде, в каком его интерпретировал браузер. Этот API берет начало в «[DOM уровень 2: getComputedStyle()][2]» и «[CSS уровень 2: вычисленные значения][3]», в которых вычисленный стиль определён как абсолютное значение. 

Её можно использовать для свойств вроде `font-size`, которые принимают только один параметр и безопасно конвертируются в пиксельные значения. Однако она не подходит для обработки браузерами сокращенных записей свойств вроде `margin` — некоторые браузеры не возвращают никакое значение, некоторые возвращают что-то полу-полезное. Кроме того есть еще свойства, которые могут принимать разные, но эквивалентные значения, например `bold` и `700` для `font-weight`. WebKit содержит [глюк][4], который извлекает вычисленное значение свойств из псевдо-эллементов. 

*Особенности, описанные в этой статье, были обнаружены в январе 2013 года на Firefox 18 (Gecko), Opera 12.12 (Presto), Internet Explorer 10 (Trident), Safari 6.0.2 (WebKit), Chrome 23 (WebKit), а также ночных сборках Gecko и WebKit.*

Без дальнейших церемоний **давайте погрузимся в спецификации и их реализацию**, в мир пронизанный недоразумениями. Пожалуйста примите во внимание, что для лаконичности, я не использовал вендорные префиксы в примерах.

> «Трудно иметь дело с тем, чего не знаешь. Проще руководствоваться предположениями» — Д-р Аксель Раушмайер (Dr. Axel Rauschmayer)

… Однако предположения часто оказываются неверными. Информация в этой статье была получена в результате работы над [тестовым комплексом для переходов CSS3][5].

<a id="1-specifying-a-transition"></a>
## 1. Описание перехода

Кроме сокращенного [свойства][6] `transition`, в спецификации по переходам CSS3 указаны следующие четыре свойства CSS для описания анимированного изменения состояния:

* `transition-property`,

* `transition-duration`,

* `transition-delay`,

* `transition-timing-function`.

### Свойства CSS для которых выполняется переход

[Свойство][7] `transition-property` определяет **свойство (или свойства), для которых будет осуществляться анимация**. Значением по умолчанию является `all`, которое означает что все свойства, для которых может быть применён переход, будут анимированы при изменении (если для `transition-duration` значение больше `0s`). Свойство принимает одно значение или набор значений, разделенных запятыми (как и все свойства типа `transition-*`).

Спецификация постановляет что браузер должен принять и сохранить любое свойство, которое он не поддерживает. Из чего следует что в примере ниже переход будет осуществляться для свойства `padding` длительностью в 2 секунды. 

    transition-property: foobar, padding; 
    transition-duration: 1s, 2s;

Наперекор спецификации WebKit интерпретирует вышеизложенное как `transition-property: all`. Firefox и Opera интерпретируют этот код как `transition-property: all, padding`.

### Длительность перехода

Свойство `transition-duration` определяет **количество времени** которое должно пройти от начала изменения состояния вследствии перехода до его конца. Оно принимает значение времени в секундах или миллисекундах (например `2.3s` и `2300ms` обозначают 2.3 секунды).

Хотя в спецификации чётко указано, что значения должны быть положительными числами, Opera также поддерживает `-5s`, по крайней мере для `getComputedStyle()`. Opera и Internet Explorer (IE) не поддерживают значения меньше `10ms`, хотя в спецификации нет ни слова о таком ограничении. Справедливости ради, вы бы в любом случае не заметили переход длящийся 9 миллисекунд. WebKit (за исключением текущей ночной сборки) содержит ошибку в реализации `getComputedStyle()`, которая возвращает значения вроде `0.009999999776482582s` вместо `0.01s`. По крайней мере, все браузеры возвращают значения в секундах. 

### Задержка перехода

Свойство `transition-delay` определяет количество **времени которое должно пройти до начала** перехода, оно также принимает значение времени. Задержка `delay` может принимать отрицательное значение, при котором переход будет начинаться немедленно и выглядеть так, будто начался на заданное количество времени раньше. 

Так же как и для `transition-duration`, IE и Opera не поддерживают значения между `-10ms` и `10ms`. У WebKit в этом случае снова проблемы с плавающей десятичной запятой. 

### Временная функция

[Свойство][10] `transition-timing-function` определяет **математическую функцию, которая будет использоваться для рассчёта значения свойства** во время `t`. Есть три её основных типа: `cubic-bezier(x1, y1, x2, y2)`, `step(<number>`, `start|end)` и ключевые слова, которые позначают стандартные кривые Безье. Скорее всего, вам уже знакомы ключевые слова `linear`, `ease`, `ease-in`, `ease-out` и `ease-in-out`. Понимать математические вычисления кривых Безье не обязательно, можно использовать чудесный [редактор кривых Безье][12], созданный [Леа Веру (Lea Verou)][11]. В то время как при использовании кривых Безье переходы получаются плавными, при использовании функций `step()` — наоборот. Они задают скачкообразный переход к следующему значению (т.е. следующему шагу) с одинаковым интервалом. Это даёт покадровую анимацию, примеры можно посмотреть в статье «[Анимация набора текста на чистом CSS3 с помощью steps()][13]».

Вычисленное значение `linear` обычно представлено в таком виде: `cubic-bezier(0, 0, 1, 1)` кроме WebKit, который возвращает `linear`. Но волноваться не стоит, WebKit возвращает `cubic-bezier(0.25, 0.1, 0.25, 1)` вместо `ease`. Текущая ночная сборка WebKit, однако, возвращает ключевое слово для всех стандартных ключевых слов. Если смотреть на перспективы позитивнее, WebKit стремится к тому чтобы перестать противоречить самому себе и через несколько месяцев он будет противоречить только другим браузерам. 

В спецификации обусловлено что значение `x` должно быть между `0` и `1`, в то время как значение `y` может выходить за пределы этого диапазона. Вопреки спецификации, WebKit допускает значения `x` выходящие за ограничение, по крайней мере вычислительно. Во время написания этой статьи браузер Android (версии 4.0) смешивает диапазоны для `x` и `y`, по сути препятствуя эффекту подпрыгивания. 

<a id="2-when-a-transition-is-complete"></a>
## 2. Когда переход завершен

Я уже писал что переходы CSS выполняются асинхронно. В спецификации предложено событие `TransitionEnd` для возможности синхронизировать JavaScript с окончанием перехода. К сожалению это событие недостаточно подробно описано в спецификации. По существу, в ней сказано всего лишь что событие должно быть активировано для каждого свойства, для которого был осуществлен переход. Если описывать ситуацию одним словом, «кошмар» вполне подходит. 

В спецификации указано, что когда переход задан для сокращенной записи свойств (таких как `padding`), он должен осуществляться для всех свойств, которые эта запись в себя включает (`padding-top`, `padding-right`, и т.д.), однако не уточняется какое свойство должно быть названо в событии `TransitionEnd`. В то время как Gecko, Trident и Presto сошлись на запуске событий для всех компонентов полной записи свойства (таких как `padding-top`), даже если переход был задан для сокращенной записи свойства (такой как `padding`), **WebKit воспользовался возможностью пустить всё наперекосяк**. WebKit вызывает событие для `padding` если (это обязательное условие) вы указали `transition-property: padding`, однако `transition-property: all` запускает событие для `padding-left` и других. По непонятной причине браузер Safari 6.0.1 на iPhone вызывает события для `font-size` и `line-height` когда осуществляется переход для `padding`. Вы еще не запутались?

    .example {
      padding: 1px;
      transition-property: padding;
      transition-duration: 1s;
    }

    .example:hover {
      padding: 10px;
    }

CSS код приведенный выше запустит разные события `TransitionEnd` в разных браузерах:

Gecko, Trident, Presto

`padding-top`, `padding-right`, `padding-bottom`, `padding-left`

WebKit

`padding`

    .example {
      padding: 1px;
      transition-property: all, padding;
      transition-duration: 1s;
    }

    .example:hover {
      padding: 10px;
    }

CSS код приведенный выше запустит разные события `TransitionEnd` в разных браузерах:

Gecko, Trident, Presto, WebKit

`padding-top`, `padding-right`, `padding-bottom`, `padding-left`

Safari 6.0.1 на iPhone (не iPad, имейте ввиду!)

`padding-top`, `padding-right`, `padding-bottom`, `padding-left`, `font-size`, `line-height`

Я упоминал что можно задать отрицательное значение `transition-delay` чтобы переход начинался не с начала. Но что же происходит при `transition-duration: 1s; transition-delay: -1s;`? Gecko и WebKit сразу отображают конечное значение и вызывают событие. Trident и Presto не вызывают никаких событий. 

**Проблема с плавающей десятичной запятй, характерная для WebKit** при `getComputedStyle()`, также встречается во всех браузерах при `TransitionEnd.elapsedTime`. `Math.round(event.elapsedTime * 1000) / 1000` может это «исправить».

WebKit и IE ввели [нестандартное дополнение][14] для `background-position`, не указанное в спецификации, которое приводит к вызову событий `TransitionEnd` для `background-position-x` и `background-position-y`, вместо `background-position`.

Таким образом, даже зная что переход произошёл, вы не можете рассчитывать на `TransitionEnd.propertyName`. Вы можете написать тонны кода JavaScript чтобы корректировать поведение, но вы не можете гарантировать его стабильную работу в будущем без проведения соответствующего обнаружения признаков для каждого свойства. В том числе для свойств, к которым, как вам кажется, не может быть применена анимация. 

<a id="3-transitionable-properties"></a>
## 3. Свойства, для которых могут быть применены переходы

В спецификации [приведен список свойств CSS][15], для которых браузеры должны поддерживать анимированые переходы. Этот список содержит свойства CSS2.1. Для всех более новых свойств добавляется пометка о возможности применения анимации в соответствующей спецификации, которая их описывает, так как можно увидеть для свойства `order` [в спецификации Flexible Box Layout][16]. 

Важным фактором является тип значения, которое принимает свойство. Свойство `margin-top` принимает значения в единицах длины и процентах, но согласно списку свойств CSS, для которых могут быть применены переходы, анимация может быть задана только для значений длины. Это однако не помешало разработчикам браузеров ввести поддержку переходов для значений в процентах. Со свойством `word-spacing` совсем другая история. Согласно спецификации, его значение в процентах может быть анимировано, но ни один браузер такую анимацию не поддерживает. 

Для свойства осуществлятся переход от значения A до значения B без учёта событий `TransitionEnd` если его значение `getComputedStyle()` отличается от A и B в соответствующее время перехода. Поскольку нет такого события как «изменение значения свойства CSS», вам остается **только вести наблюдение за DOM**. Решение `setTimeout()` не подходит для быстрых переходов (длительностью в менее чем несколько сотен миллисекунд). Вам поможет `requestAnimationFrame()`. Браузер выведет предупреждение перед началом перерисовки изображения на экране, что позволяет захватить пару промежуточных значений во время переходов. У всех браузеров кроме Opera уже есть эта функция. 

Чтобы не раздувать размер этой статьи размещением полной таблицы совместимости, я отправил полученные результаты Оли Стадхолму (Oli Studholme, [@boblet][17]) и он обновил свой список «[Свойства CSS, к которым может быть применена анимация][18]». 

<a id="4-priority-of-transition-properties"></a>
## 4. Приоритет свойств переходов

Спецификация для [свойства][19] `transition-property` говорит что мы можем задавать свойство несколько раз:

> « Если свойство задано несколько раз в значении `transition-property` (само по себе, в сокращенной записи, или через значение `all`), то начавшийся переход будет иметь значение продолжительности, задержки и синхронизации, соответствующее последнему пункту в значении `transition-property`, которое определяет возможность анимации»

Таким образом, мы можем сделать переход для `padding` длительностью в 1 секунду и одновременно переход для `padding-left` длительностью в 2 секунды; или определить стиль перехода по умолчанию используя `transition-property: all` и переписать его для некоторых свойств.

В Firefox и IE все это отлично работает. В Opera же порядок приоритетов перемешан. Вместо простого использования *последнего* применяемого свойства из списка, `padding-left` получает больший приоритет, чем `padding` и `all`.

Настоящую проблему представляет WebKit. В нем, если свойство задано несколько раз, переход почему-то осуществляется несколько раз. Чтобы окончательно вывести WebKit из себя, попробуйте запустить переход для `transition-property: padding, padding-left` с очень малым `transition-duration: 0.1s` (предупреждение: эпилептикам этого делать не стоит). WebKit отображает переход, по крайней мере, дважды. Но настоящая прелесть – это события `TransitionEnd`, которых для одного перехода вы можете получить **сотни**.

<a id="5-transitioning-from-and-to-auto"></a>
## 5. Переход от и к `auto`

Значение свойства CSS `auto` можно интерпретировать как «Уважаемые браузеры, пожалуйста, вычислите приемлемое значение для вот этого». Абзацы (`<p>`) и любые блочные элементы будут иметь ту же ширину, что и их родительские элементы, если для них установлено `width: auto`. В определенных ситуациях, когда вы проводите изменения от `width: auto` до конкретной ширины, возникает необходимость создания перехода для этих изменений. Спецификация не выступает ни за ни против использования значений `auto` для свойств с переходами. 

В Firefox, IE и Opera невозможен переход от или к значениям `auto`. У IE существует небольшое исключение только для `z-index`. WebKit, с другой стороны, поддерживает переход от и к значению `auto` практически для любого CSS свойства, которое его принимает. WebKit не очень хорошо воспринимает команды `clip`; для этого свойства будет вызываться только событие TransitionEnd без генерации или показа любого промежуточного значения или состояния во время перехода.

Другие свойства, такие как, например, `width` и `height` в WebKit ведут себя совсем не так, как вы ожидаете. Если установлено значение `width: auto` с расчетом ширины 300px, а вы задали переход от него до 100px, то на самом деле это не значит, что ширина уменьшится от 300 до 100 пикселей. Вместо этого, она будет увеличиваться от 0 до 100 пикселей.

Полную таблицу совместимости можно просмотреть в публикации «[Свойства CSS, к которым может быть применена анимация][20]»

<a id="6-implicit-transitions"></a>
## 6. Неявные переходы

«Неявные переходы» происходят, когда изменение одного свойства влечет за собой переход для другого свойства. Тот же явление наблюдается, если вы изменяете свойства родительского элемента и это вызывает переход зависимого или унаследованного свойства у дочерних элементов. Немного запутанно, не правда ли? Рассмотрим `font-size: 18px; padding: 2em;` — отступы рассчитываются как `2 × font-size`, ведь именно так работают em, что даёт нам 36 пикселей.

Существуют различные *относительные типы величин*: `<percentage>`, `<length>`, `em`, `rem`, `vh`, `vw` и т.д. Использование относительных величин, например, `padding: 2em` заставляет браузер выполнять перерасчёт значения функции `getComputedValue()` каждый раз, когда происходит изменение зависимого от него  значения (например, `font-size`). В свою очередь это вызывает переход для `padding`, поскольку изменился вычисленный стиль. Этот переход считается «неявным», потому что свойство `padding` не было изменено намеренно.

Большинство браузеров поддерживает возможность неявных переходов. Исключением является IE 10, который поддерживает их только для свойства `line-height`. В WebKit неявные переходы работают для всех свойств, которым можно задать переход, за исключением `vertical-align`. Кроме значений привязанных к шрифтам, есть также значения ширины (обычно `<percentage>`), значения привязанные к параметрам экрана (например, `vh` и `vw`), исходные значения, установленные по умолчанию (например, `column-gap: 1em` в Opera) и наконец, `currentColor. Все эти значения могут инициировать неявные переходы.

В браузере Firefox неявные переходы работают особенно интересно, когда и зависимые, и зависящие элементы совершили переход, но их свойства `transition-duration` или `transition-delay` не совпадают. В то время как в WebKit и Opera переходы выглядят логично, Firefox немного искажает вещи. Браузера IE эта проблема не касается, потому что он не поддерживает неявные переходы.

Не забывайте о наследовании в пределах каскада. Свойство `font-size` элемента DOM будет унаследовано его дочерними элементами, пока оно не будут перезаписано, что может привести к неявным переходам.

<a id="7-transitions-and-pseudo-elements"></a>
## 7. Переходы и псевдо-элементы

Псевдо-элементы (`:before` и `:after`) были введены в спецификации о [генерируемом содержании CSS2][21]. Если понятие генерируемого содержания для вас ново, то рекомендую  прочитать статью «[Обучение пользованию псевдо-элементами :before и :after в CSS][22]». Хотя в публикации о [контенте CSS3][23] описаны дополнительные псевдо-элементы (`::alternate`, `::outside`), они (пока) не поддерживаются. Все свойства CSS анимации также должны работать и для псевдо-элементов.

Браузеры Firefox и IE 10 поддерживают переходы для свойств псевдо-элементов в отличии от Opera, Chrome и Safari. WebKit добавил поддержку таких переходов в январе 2013 года, что из этого вышло можно посмотреть в [ночной сборке WebKit][24] и [сборке Chrome Canary][25].

Переходы генерируемого содержания принесли свой собственный набор странностей. События `TransitionEnd` не работают вообще. Когда-то в будущем, они должны будут вызываться для главного элемента и добавлять псевдо-элемент через `TransitionEnd.pseudoElement`. Но даже в разделе «[События перехода][26]» в редакторском черновике «CSS переходы» это еще толком не описано.

Когда-то возникала необходимость в изменении значения свойства `content` чтобы в определенных обстоятельствах IE 8 повторно прорисовывал элемент (например, при входе в состояние `:hover`). Оказывается, что такое решение для старых IE препятствует этой способности для всех остальных браузеров. Так что, при попытке реализации перехода для свойства псевдо-элемента, убедитесь, что `content` не изменен.

IE 10 не будет осуществлять переход для состояния `:hover` псевдо-элемента, если его родительский элемент не имеет такое же состояние `:hover`:

    .some-selector:before {
      content: "hello";
      color: red;
      transition: all 1s linear 0s;
    }

    .some-selector:hover:before {
      color: green;
    }
    /* Следующее правило нужно для перехода :before при наведении курсора в IE 10 */
    .some-selector:hover {}

Вся странность этой проблемы не в том, что вам нужно наличие (возможно пустого) состояния `:hover` у родительского элемента, а в том что если его у вас нет, IE 10 будет интерпретировать `:hover` как `:active` (т.е. как активный элементу при клике по нем мышью). Самое странное то, что состояние `:active` сохраняется даже после щелчка и удаляется только при повторном щелчке по документе.

<a id="8-background-tabs"></a>
## 8. Фоновые вкладки

На момент написания статьи, IE 10 является единственным браузером, который реагирует на расположение вкладок в фоне или на переднем плане. Хотя текущий переход и будет завершен если вкладка принимает фоновый режим, новые переходы выполняться не будут. IE 10 подождёт, пока вкладка не выйдет на передний план перед началом любых новых переходов. К счастью, IE 10 уже поддерживает [API видимости страницы][27], который позволяет разработчикам контролировать текое поведение.

Можно ожидать, что подобное ждет и другие браузеры, поскольку они продолжают игнорировать фоновые вкладки.

<a id="9-invisible-elements"></a>
## 9. «Невидимые» элементы

Выполняются ли переходы для элементов DOM, которые не привязаны к DOM? Нет, ни в одном браузере они не выполняются, да и зачем? А как насчет скрытых элементов? Разработчики большинства браузеров пришли к выводу, что нет никакой необходимости запускать переходы для невидимых (т.е. неотрисованных) элементов. У разработчиков Opera другое мнение относительно этого вопроса: у них переходы работают независимо от того, отрисован элемент или нет.

<a id="10-transitioning-before-the-dom-is-ready"></a>
## 10. Осуществление перехода до полной загрузки DOM

Событие `DOMContentLoaded` срабатывает когда документ выходит из режима анализа. Если вы работаете с JQuery, в данный момент мы говорим о `jQuery.ready()`. Переходы могут быть произведены *до того*, как будет вызвано это событие.

<a id="11-rendering-quirks"></a>
## 11. Особенности отрисовки

До этого момента я описал проблемы, обнаруженные при тестировании описаний изложенных в спецификации. Тесты проводились в автоматическом режиме. Однако как оказалось, несколько дополнительных проблем видны только человеку. Следующие неточности были обнаружены различными разработчиками и вполне могут повлиять на результаты вашей работы с переходами.

В данное время переход фона от градиента к градиенту невозможен. Переход от градиента к одному цвету возможен — но с важной оговоркой. Если переход начинается с градиента, то переход будет происходить от белого цвета до целевого. При этом будет наблюдаться секундный проблеск белого цвета в начале перехода. Данный эффект можно [наблюдать][28] во всех существующих браузерах.

Firefox использует другой алгоритм для отрисовки (и сглаживания) изображений в процессе анимирования ([посмотреть пример][29]). Судя по всему, Gecko жертвует качеством в пользу производительности при выполнении анимации. Обратите внимание, что это происходит [при низком показателе `transform: scale()`][30].

В Firefox анимация перехода от `a:visited` к `a:hover` или наоборот не будет выполнена должным образом. Вместо этого будут происходить прыжки от `a:visited` к `a:link`, а затем переход к `a:hover`, как вы можете увидеть [в этом примере][31]. Частично об этом говорится в публикации «[Конфиденциальность и селектор :visited][32]» от разработчиков Mozilla. IE 10 поддерживает такие переходы должным образом так же как и Chrome, Safari и Opera, и кроме этого он отображает переход от `a:link` к `a:visited` при загрузке страницы. 

Переходы для нескольких свойств не синхронизированы в Firefox и Webkit. [В этом примере][33] вы можете посмотреть как уменьшение значения `border` на ту же величину, на которую увеличивается значение `padding` (и наоборот) заставляет последующий контент слегка дрожать. IE 10 и Opera это работает правильно.

[Как вы можете увидеть][34], Firefox не выполняет анимацию свойств элемента, если позиционирование одного из родительских свойств было изменено. Webkit, Opera и IE 10 делают все правильно.

<a id="12-recommendations-for-the-specification"></a>
## 12. Рекомендации касательно спецификации

Проанализировав спецификацию сверху донизу и протестировав все ее описания, я выделил несколько изменений, которые были бы полезными:

* Добавление события `TransitionsEnd` (обратите внимание на множественное число), которое запускалось бы как только *все* переходы для элемента завершены. Это позволит получить список свойств, которые были анимированы — но я не могу придумать пример когда нужно знать для какого свойства был выполнен переход вдобавок к информации когда все анимации завершены.

* Добавление события `TransitionStart`, которое бы запускалось для каждого свойства, для которого начинается переход. Поскольку события DOM не экономны, а цикл событий и поток отрисовки в JavaScript не обязательно блокируют друг друга, одно событие TransitionsStart (снова в множественном числе) кажется лучшим решением. Я не понимаю, почему я у меня должна быть возможность применить событие `cancel`, ведь это будет что-то вроде «выстрелил и забыл».

* Более подробное описание для чего должно быть вызвано событие TransitionEnd. Проблема с `padding` и `padding-left` в WebKit довольно неприятна.

* Добавление четкого обьяснения того как должны осуществляться «неявные переходы», например, для `line-height: 1em` при `transition-property: font-size`.

* Добавление псевдо-класса `::transitioning`, который позволяет задать `pointer-events: none` для предотвращения случайного отображения состояния наведения (и прочего). Хитрость тут в том, чтобы предотвратить применение стилей, которые будут вызывать новый переход или могут привести к изменению уже запущенного перехода.

В дополнение к этим предложениям, мы должны иметь возможность выполнять ряд общих (простых) действий без использования объемных кодов JavaScript для решения проблемы:

* Иногда может возникнуть необходимость в полном отключении всех переходов, например, такая ситуация может возникнуть при изменении макета, когда нужно рассчитать размеры и положение элементов до того как переходы будут видны посетителям.

* Иногда возникает желание удалить объект из DOM и вы хотите, чтобы этот процесс был анимированным. Скорее всего вы добавите класс, подождете завершение события `TransitionEnd`, а затем удалите элемент.

* Подобно ситуации с удалением некоторых элементов, может возникнуть необходимость в добавлении нового элемента и анимирования его внешнего вида. Вы должны вставить элемент, установить «невидимый стиль», запустить перерисовку, а затем вернуться к фактическому стилю нового элемента.

* Изменение порядка, скрытие и отображение элементов - это привычные действия для любого веб-приложения. В настоящее время для выполнения этих задач требуется запуск специальной утилиты, например, такой как [Isotope][35]. Использование возможностей CSS может сэкономить несколько байтов.

<a id="13-use-the-delay-luke"></a>
## 13. Используй `delay`, Люк! 

Представьте себе некоторое количество элементов размещенных близко друг к другу. Представьте, что стиль этих элементов при наведении курсора мыши может изменяться. Представьте перемещение курсора (умеренно быстрое) по этим элементам. Что происходит? Правильно: вы увидите что [стили этих элементов мигают][36]. 

Добавив относительно короткую задержку перехода, вы можете [регулировать этот эффект][37]; задержка в 20 миллисекунд не воспринимается человеческим глазом, но этого достаточно для перемещения курсора мыши по небольшим элементам. Не будет казаться что переходы отстают и визуальное раздражение просто исчезает. Простой трюк, я знаю.

<a id="14-conclusion"></a>
## 14. Заключение

* Будьте очень осторожны при использовании `transition-property: all`. Вы *можете* вызвать события `TransitionEnd` для свойств переходов, которые даже не ожидали.

* Будьте осторожны при использовании сокращенных записей, так как число вызванных событий колеблется в разных браузерах.

* Браузеры Opera и IE не инициируют события когда отрицательная задержка равна длительности перехода.

* У WebKit серьезные проблемы с приоритетом свойств, таких как `transition-property: margin, margin-left`. Пока постарайтесь их не использовать.

* Браузер IE не поддерживает неявные переходы — например, запуск перехода для `padding: 2em`, когда изменяется `font-size`.

* Браузеры Firefox и Opera не понимают `transition-property: all, width`.

* В Opera приоритеты свойств перемешаны.

* Переходы для псевдо-элементов не вызывают события `TransitionEnd`.

* В браузере IE 10 возникают странные ошибки при использовании `:hover` для перехода псевдо-элементов.

* Спецификации еще предстоит долгий путь к совершенству.

### Дополнительные ресурсы

Если вы интересуетесь переходами и анимацией и хотите использовать их с умом, взгляните на эти чудесные источники:

* «[Создание динамических визуальных эффектов с помощью переходов CSS3][38]», Майк Сьерра (Mike Sierra), Web Platform Docs.

* «[Все, что нужно знать о переходах CSS][39]», Алекс МакКоу (Alex MacCaw).

* [Эффективные переходы][40].

* «[Интерфейсы с возможностью переходов][41]», Паскаль де Сильва (Pasquale D’Silva).

* [Анимирование][42] (образцы переходов), Леа Веру (Lea Verou).

* «[Свойства CSS, которые можна анимировать][43]», Оли Стадхольм.

*Хочу сказать спасибо [Оли Стадхольму][44] и [Леа Веру][45] за то, что нашли время просмотреть эту статью до публикации. Также хочу выразить благодарность [Петеру Линсу (Peter Linss)][46] за ознакомление со спецификой инфраструктуры тестирования рабочей группы CSS.*

[1]: http://blog.alexmaccaw.com/css-transitions
[2]: http://www.w3.org/TR/DOM-Level-2-Style/css.html#CSS-CSSview-getComputedStyle
[3]: http://www.w3.org/TR/1998/REC-CSS2-19980512/cascade.html#computed-value
[4]: https://bugs.webkit.org/show_bug.cgi?id=106535
[5]: http://test.csswg.org/shepherd/search/spec/CSS3-TRANSITIONS/
[6]: http://www.w3.org/TR/css3-transitions/#transition-property-property
[7]: http://www.w3.org/TR/css3-transitions/#transition-property-property
[8]: http://www.w3.org/TR/css3-transitions/#transition-duration-property
[9]: http://www.w3.org/TR/css3-transitions/#transition-delay-property
[10]: http://www.w3.org/TR/css3-transitions/#transition-timing-function-property
[11]: https://twitter.com/LeaVerou
[12]: http://cubic-bezier.com/#.17,.67,.83,.67
[13]: http://lea.verou.me/2011/09/pure-css3-typing-animation-with-steps/
[14]: http://snook.ca/archives/html_and_css/background-position-x-y
[15]: http://www.w3.org/TR/css3-transitions/#animatable-css
[16]: http://www.w3.org/TR/css3-flexbox/#order-property
[17]: https://twitter.com/boblet
[18]: http://oli.jp/2010/css-animatable-properties/
[19]: http://www.w3.org/TR/css3-transitions/#transition-property-property
[20]: http://oli.jp/2010/css-animatable-properties/
[21]: http://www.w3.org/TR/CSS2/generate.html
[22]: http://coding.smashingmagazine.com/2011/07/13/learning-to-use-the-before-and-after-pseudo-elements-in-css/
[23]: http://www.w3.org/TR/css3-content/
[24]: http://nightly.webkit.org/
[25]: https://www.google.com/intl/en/chrome/browser/canary.html 
[26]: http://dev.w3.org/csswg/css-transitions/#transition-events
[27]: http://www.w3.org/TR/page-visibility/
[28]: http://jsbin.com/oyuciz/1
[29]: http://jsfiddle.net/fSjUb/3/
[30]: https://bugzilla.mozilla.org/show_bug.cgi?id=860261
[31]: http://jsbin.com/avabaw/1
[32]: https://developer.mozilla.org/en-US/docs/CSS/Privacy_and_the_:visited_selector
[33]: http://jsbin.com/uxenaz/1
[34]: http://jsbin.com/azipul/1
[35]: http://isotope.metafizzy.co/
[36]: http://jsbin.com/irazox/1
[37]: http://jsbin.com/egeniz/1
[38]: http://docs.webplatform.org/wiki/tutorials/css_transitions
[39]: http://blog.alexmaccaw.com/css-transitions
[40]: http://www.ui-transitions.com/#home
[41]: https://medium.com/design-ux/926eb80d64e3
[42]: http://leaverou.github.io/animatable/
[43]: http://oli.jp/2010/css-animatable-properties/
[44]: http://oli.jp/
[45]: http://lea.verou.me/
[46]: https://blog.linss.com/
[47]: https://medium.com/design-ux/926eb80d64e3